2019-05-15 16:48:04 database: flush
org.h2.message.DbException: Внутренняя ошибка: "java.lang.IllegalStateException: The file is locked: nio:C:/Users/мвидео/Desktop/spring-start/database.mv.db [1.4.199/7]"
General error: "java.lang.IllegalStateException: The file is locked: nio:C:/Users/мвидео/Desktop/spring-start/database.mv.db [1.4.199/7]" [50000-199]
	at org.h2.message.DbException.get(DbException.java:194)
	at org.h2.message.DbException.convert(DbException.java:347)
	at org.h2.mvstore.db.MVTableEngine$1.uncaughtException(MVTableEngine.java:90)
	at org.h2.mvstore.MVStore.handleException(MVStore.java:2787)
	at org.h2.mvstore.MVStore.panic(MVStore.java:441)
	at org.h2.mvstore.MVStore.<init>(MVStore.java:404)
	at org.h2.mvstore.MVStore$Builder.open(MVStore.java:3343)
	at org.h2.mvstore.db.MVTableEngine$Store.open(MVTableEngine.java:162)
	at org.h2.mvstore.db.MVTableEngine.init(MVTableEngine.java:95)
	at org.h2.engine.Database.getPageStore(Database.java:2739)
	at org.h2.engine.Database.open(Database.java:769)
	at org.h2.engine.Database.openDatabase(Database.java:319)
	at org.h2.engine.Database.<init>(Database.java:313)
	at org.h2.engine.Engine.openSession(Engine.java:69)
	at org.h2.engine.Engine.openSession(Engine.java:201)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:178)
	at org.h2.engine.Engine.createSession(Engine.java:161)
	at org.h2.engine.Engine.createSession(Engine.java:31)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:336)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:169)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:148)
	at org.h2.Driver.connect(Driver.java:69)
	at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:136)
	at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:369)
	at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:198)
	at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:467)
	at com.zaxxer.hikari.pool.HikariPool.access$100(HikariPool.java:71)
	at com.zaxxer.hikari.pool.HikariPool$PoolEntryCreator.call(HikariPool.java:706)
	at com.zaxxer.hikari.pool.HikariPool$PoolEntryCreator.call(HikariPool.java:692)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: org.h2.jdbc.JdbcSQLNonTransientException: Внутренняя ошибка: "java.lang.IllegalStateException: The file is locked: nio:C:/Users/мвидео/Desktop/spring-start/database.mv.db [1.4.199/7]"
General error: "java.lang.IllegalStateException: The file is locked: nio:C:/Users/мвидео/Desktop/spring-start/database.mv.db [1.4.199/7]" [50000-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:502)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	... 33 more
Caused by: java.lang.IllegalStateException: The file is locked: nio:C:/Users/мвидео/Desktop/spring-start/database.mv.db [1.4.199/7]
	at org.h2.mvstore.DataUtils.newIllegalStateException(DataUtils.java:883)
	at org.h2.mvstore.FileStore.open(FileStore.java:166)
	at org.h2.mvstore.MVStore.<init>(MVStore.java:390)
	... 27 more
Caused by: java.nio.channels.OverlappingFileLockException
	at sun.nio.ch.SharedFileLockTable.checkList(FileLockTable.java:255)
	at sun.nio.ch.SharedFileLockTable.add(FileLockTable.java:152)
	at sun.nio.ch.FileChannelImpl.tryLock(FileChannelImpl.java:1107)
	at org.h2.store.fs.FileNio.tryLock(FilePathNio.java:121)
	at java.nio.channels.FileChannel.tryLock(FileChannel.java:1155)
	at org.h2.mvstore.FileStore.open(FileStore.java:163)
	... 28 more
2019-05-15 16:55:02 jdbc[3]: exception
org.h2.jdbc.JdbcSQLNonTransientConnectionException: База данных уже закрыта (чтобы отключить автоматическое закрытие базы данных при останове JVM, добавьте ";DB_CLOSE_ON_EXIT=FALSE" в URL)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:617)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.get(DbException.java:170)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1571)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1547)
	at org.h2.jdbc.JdbcConnection.getAutoCommit(JdbcConnection.java:521)
	at com.zaxxer.hikari.pool.HikariProxyConnection.getAutoCommit(HikariProxyConnection.java)
	at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:46)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.jdbcStatement(GenerationTargetToDatabase.java:77)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:53)
	at org.hibernate.tool.schema.internal.SchemaDropperImpl$DelayedDropActionImpl.perform(SchemaDropperImpl.java:536)
	at org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:815)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:496)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:679)
	at com.sun.proxy.$Proxy83.close(Unknown Source)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.destroy(AbstractEntityManagerFactoryBean.java:599)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945)
2019-05-15 16:55:02 jdbc[3]: exception
org.h2.jdbc.JdbcSQLNonTransientConnectionException: База данных уже закрыта (чтобы отключить автоматическое закрытие базы данных при останове JVM, добавьте ";DB_CLOSE_ON_EXIT=FALSE" в URL)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:617)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.get(DbException.java:170)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1571)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1547)
	at org.h2.jdbc.JdbcConnection.clearWarnings(JdbcConnection.java:708)
	at com.zaxxer.hikari.pool.ProxyConnection.close(ProxyConnection.java:242)
	at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.closeConnection(DatasourceConnectionProviderImpl.java:127)
	at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.releaseConnection(JdbcEnvironmentInitiator.java:185)
	at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.release(DdlTransactionIsolatorNonJtaImpl.java:83)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.release(GenerationTargetToDatabase.java:90)
	at org.hibernate.tool.schema.internal.SchemaDropperImpl$DelayedDropActionImpl.perform(SchemaDropperImpl.java:547)
	at org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:815)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:496)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:679)
	at com.sun.proxy.$Proxy83.close(Unknown Source)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.destroy(AbstractEntityManagerFactoryBean.java:599)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945)
2019-05-15 16:55:56 jdbc[3]: exception
org.h2.jdbc.JdbcSQLNonTransientConnectionException: База данных уже закрыта (чтобы отключить автоматическое закрытие базы данных при останове JVM, добавьте ";DB_CLOSE_ON_EXIT=FALSE" в URL)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:617)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.get(DbException.java:170)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1571)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1547)
	at org.h2.jdbc.JdbcConnection.getAutoCommit(JdbcConnection.java:521)
	at com.zaxxer.hikari.pool.HikariProxyConnection.getAutoCommit(HikariProxyConnection.java)
	at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:46)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.jdbcStatement(GenerationTargetToDatabase.java:77)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:53)
	at org.hibernate.tool.schema.internal.SchemaDropperImpl$DelayedDropActionImpl.perform(SchemaDropperImpl.java:536)
	at org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:815)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:496)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:679)
	at com.sun.proxy.$Proxy83.close(Unknown Source)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.destroy(AbstractEntityManagerFactoryBean.java:599)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945)
2019-05-15 16:55:56 jdbc[3]: exception
org.h2.jdbc.JdbcSQLNonTransientConnectionException: База данных уже закрыта (чтобы отключить автоматическое закрытие базы данных при останове JVM, добавьте ";DB_CLOSE_ON_EXIT=FALSE" в URL)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:617)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.get(DbException.java:170)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1571)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1547)
	at org.h2.jdbc.JdbcConnection.clearWarnings(JdbcConnection.java:708)
	at com.zaxxer.hikari.pool.ProxyConnection.close(ProxyConnection.java:242)
	at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.closeConnection(DatasourceConnectionProviderImpl.java:127)
	at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.releaseConnection(JdbcEnvironmentInitiator.java:185)
	at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.release(DdlTransactionIsolatorNonJtaImpl.java:83)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.release(GenerationTargetToDatabase.java:90)
	at org.hibernate.tool.schema.internal.SchemaDropperImpl$DelayedDropActionImpl.perform(SchemaDropperImpl.java:547)
	at org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:815)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:496)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:679)
	at com.sun.proxy.$Proxy83.close(Unknown Source)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.destroy(AbstractEntityManagerFactoryBean.java:599)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945)
2019-05-15 16:56:40 jdbc[3]: exception
org.h2.jdbc.JdbcSQLNonTransientConnectionException: База данных уже закрыта (чтобы отключить автоматическое закрытие базы данных при останове JVM, добавьте ";DB_CLOSE_ON_EXIT=FALSE" в URL)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:617)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.get(DbException.java:170)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1571)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1547)
	at org.h2.jdbc.JdbcConnection.getAutoCommit(JdbcConnection.java:521)
	at com.zaxxer.hikari.pool.HikariProxyConnection.getAutoCommit(HikariProxyConnection.java)
	at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.getIsolatedConnection(DdlTransactionIsolatorNonJtaImpl.java:46)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.jdbcStatement(GenerationTargetToDatabase.java:77)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:53)
	at org.hibernate.tool.schema.internal.SchemaDropperImpl$DelayedDropActionImpl.perform(SchemaDropperImpl.java:536)
	at org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:815)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:496)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:679)
	at com.sun.proxy.$Proxy85.close(Unknown Source)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.destroy(AbstractEntityManagerFactoryBean.java:599)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945)
2019-05-15 16:56:40 jdbc[3]: exception
org.h2.jdbc.JdbcSQLNonTransientConnectionException: База данных уже закрыта (чтобы отключить автоматическое закрытие базы данных при останове JVM, добавьте ";DB_CLOSE_ON_EXIT=FALSE" в URL)
Database is already closed (to disable automatic closing at VM shutdown, add ";DB_CLOSE_ON_EXIT=FALSE" to the db URL) [90121-199]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:617)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:427)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.get(DbException.java:170)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1571)
	at org.h2.jdbc.JdbcConnection.checkClosed(JdbcConnection.java:1547)
	at org.h2.jdbc.JdbcConnection.clearWarnings(JdbcConnection.java:708)
	at com.zaxxer.hikari.pool.ProxyConnection.close(ProxyConnection.java:242)
	at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.closeConnection(DatasourceConnectionProviderImpl.java:127)
	at org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess.releaseConnection(JdbcEnvironmentInitiator.java:185)
	at org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl.release(DdlTransactionIsolatorNonJtaImpl.java:83)
	at org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.release(GenerationTargetToDatabase.java:90)
	at org.hibernate.tool.schema.internal.SchemaDropperImpl$DelayedDropActionImpl.perform(SchemaDropperImpl.java:547)
	at org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:815)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.invokeProxyMethod(AbstractEntityManagerFactoryBean.java:496)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean$ManagedEntityManagerFactoryInvocationHandler.invoke(AbstractEntityManagerFactoryBean.java:679)
	at com.sun.proxy.$Proxy85.close(Unknown Source)
	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.destroy(AbstractEntityManagerFactoryBean.java:599)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:571)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:543)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1055)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:504)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1062)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1057)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1026)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:945)
2019-05-22 13:21:13 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 13:21:13 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, primary key (id)) [42001-199]
2019-05-22 13:21:54 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 13:21:54 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, primary key (id)) [42001-199]
2019-05-22 13:52:08 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 13:52:08 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, date timestamp, primary key (id)) [42001-199]
2019-05-22 13:55:55 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 13:55:55 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, date timestamp, primary key (id)) [42001-199]
2019-05-22 13:56:52 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; ожидалось "identifier"
Syntax error in SQL statement "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; expected "identifier"; SQL statement:
insert into order (amount, date, id) values (?, ?, ?) [42001-199]
2019-05-22 13:56:57 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; ожидалось "identifier"
Syntax error in SQL statement "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; expected "identifier"; SQL statement:
insert into order (amount, date, id) values (?, ?, ?) [42001-199]
2019-05-22 13:57:18 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 13:57:18 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, date timestamp, primary key (id)) [42001-199]
2019-05-22 13:57:50 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; ожидалось "identifier"
Syntax error in SQL statement "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; expected "identifier"; SQL statement:
insert into order (amount, date, id) values (?, ?, ?) [42001-199]
2019-05-22 13:58:55 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 13:58:55 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, date timestamp, primary key (id)) [42001-199]
2019-05-22 13:59:04 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; ожидалось "identifier"
Syntax error in SQL statement "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; expected "identifier"; SQL statement:
insert into order (amount, date, id) values (?, ?, ?) [42001-199]
2019-05-22 13:59:56 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; ожидалось "identifier"
Syntax error in SQL statement "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; expected "identifier"; SQL statement:
insert into order (amount, date, id) values (?, ?, ?) [42001-199]
2019-05-22 14:01:24 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE ORDER[*] IF EXISTS "; ожидалось "identifier"
Syntax error in SQL statement "DROP TABLE ORDER[*] IF EXISTS "; expected "identifier"; SQL statement:
drop table order if exists [42001-199]
2019-05-22 14:01:24 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE ORDER[*] (ID BIGINT NOT NULL, AMOUNT BIGINT, DATE TIMESTAMP, PRIMARY KEY (ID)) "; expected "identifier"; SQL statement:
create table order (id bigint not null, amount bigint, date timestamp, primary key (id)) [42001-199]
2019-05-22 14:01:31 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; ожидалось "identifier"
Syntax error in SQL statement "INSERT INTO ORDER[*] (AMOUNT, DATE, ID) VALUES (?, ?, ?) "; expected "identifier"; SQL statement:
insert into order (amount, date, id) values (?, ?, ?) [42001-199]
2019-05-22 14:02:05 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "SELECT ORDER0_.ID AS ID1_0_0_, ORDER0_.AMOUNT AS AMOUNT2_0_0_, ORDER0_.DATE AS DATE3_0_0_ FROM ORDER[*] ORDER0_ WHERE ORDER0_.ID=? "; ожидалось "identifier"
Syntax error in SQL statement "SELECT ORDER0_.ID AS ID1_0_0_, ORDER0_.AMOUNT AS AMOUNT2_0_0_, ORDER0_.DATE AS DATE3_0_0_ FROM ORDER[*] ORDER0_ WHERE ORDER0_.ID=? "; expected "identifier"; SQL statement:
select order0_.id as id1_0_0_, order0_.amount as amount2_0_0_, order0_.date as date3_0_0_ from order order0_ where order0_.id=? [42001-199]
2019-05-22 14:02:51 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "SELECT ORDER0_.ID AS ID1_0_, ORDER0_.AMOUNT AS AMOUNT2_0_, ORDER0_.DATE AS DATE3_0_ FROM ORDER[*] ORDER0_ "; ожидалось "identifier"
Syntax error in SQL statement "SELECT ORDER0_.ID AS ID1_0_, ORDER0_.AMOUNT AS AMOUNT2_0_, ORDER0_.DATE AS DATE3_0_ FROM ORDER[*] ORDER0_ "; expected "identifier"; SQL statement:
select order0_.id as id1_0_, order0_.amount as amount2_0_, order0_.date as date3_0_ from order order0_ [42001-199]
